# 我想扫描一行文字，用正则表达式去匹配（抓取）
# 在整段文本里找出符合我规则的那一部分字符串
# 正则表达式：筛选出符合规则的子串

1. match:整个正则命中字符串的所有部分（group(0)） 
-> 一般python里用**re.search() OR re.finditer()**去找到

2. capture: 用 () 包起来的子部分,存在group()里
() 表示 capturing group (捕获组)
- 指要保存的内容[系统在匹配成功后，会“捕获”每个括号内的内容，并按编号保存起来]
- group(0)（或者写成 m.group(0)）永远表示整个被匹配到的完整字符串

3. 举例解析
r"Atom\s+(\d+)\((\w)\s*\):\s*([+-]?\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)“
-> r: raw string - 原始字符串
-> 想匹配的内容：Atom   1(C ):   -0.0487

A. Atom\s+ -> 用于定位
-> Atom\s+ :匹配单词atom
- s+ :匹配一个或多个空格
-> 帮助 finditer() 匹配多行

B. (\d+)
-> (\d+) : 一个或多个数字
- d+ : 数字0-9
- 外面的括号 () 代表一个捕获组（group）
-> 整个指在Atom 1(C )里把atom后面的1作为原子序号提取出来

C. \((\w)\s*\)
->\: \ 在正则里表示“转义或特殊含义”，告诉解释器“后面的字符不是普通的符号”
- \( 和\) 匹配左右括号
- (\w) 提取一个单词字符
- \s* 0-多个空格
- :
-> (C ):    ← 整个会被这一段匹配
-> 并且 m.group(2) 会拿到 "C"

D. ([+-]?\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)
| 子模式                 | 含义                        | 示例               |
| ------------------- | ------------------------- | ---------------- |
| `[+-]?`             | 可选的正负号                    | `-0.0487` 里的 `-` |
| `\d+`               | 整数部分                      | `123`            |
| `(?:\.\d+)?`        | 可选的小数部分（注意非捕获组 `(?: … )`） | `.0487`          |
| `(?:[Ee][+-]?\d+)?` | 可选的科学计数法部分                | `E-03`, `e+5`    |
-> 匹配特征数值，考虑科学计数法